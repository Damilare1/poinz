import {promises as fsp, mkdirSync} from 'fs';
import {v4 as uuid} from 'uuid';
import path from 'path';

import processorFactory from '../../src/commandProcessor';

const DOCU_OUTPUT = path.join(__dirname, './.docu');

/**
 * an augmented wrapper around the production "commandProcessor".
 * will document every successfully processed command and it's produced events.
 *
 * @param commandHandlers
 * @param eventHandlers
 * @param store
 * @return the processCommand function
 */
export function commandProcessorFactory(commandHandlers, eventHandlers, store) {
  mkdirSync(DOCU_OUTPUT, {recursive: true});

  const processor = processorFactory(commandHandlers, eventHandlers, store);

  return async function augmentedProcessCommand(command, userId) {
    const {producedEvents, room} = await processor(command, userId);

    await documentCommand(command, userId, producedEvents);

    return {producedEvents, room};
  };
}

async function documentCommand(command, userId, producedEvents) {
  await fsp.writeFile(
    path.join(DOCU_OUTPUT, uuid()),
    JSON.stringify({command, userId, producedEvents}),
    'utf-8'
  );
}

export async function discardDocu() {
  const allFiles = await fsp.readdir(DOCU_OUTPUT);
  const deleteFilePromises = allFiles.map(async (file) => fsp.unlink(path.join(DOCU_OUTPUT, file)));
  await Promise.all(deleteFilePromises).catch((err) => {
    console.error('could not remove all docu files');
    throw new Error(err);
  });
}

/**
 * exports the gathered data into a markdown file.
 * This is called by a jest globalTeardown hook after all tests are done.
 */
export async function exportDocu() {
  const aggregatedData = await aggregateData();
  const markdown = toMarkdown(aggregatedData);
  await fsp.writeFile('commandDocu.md', markdown);
}

async function aggregateData() {
  const fileContents = await readAllFilesAndDeleteThem();

  const cmdEvMap = fileContents.reduce(
    (total, currentFile) => {
      const currentCmdName = currentFile.command.name;
      if (!total.commands[currentCmdName]) {
        total.commands[currentCmdName] = {
          command: currentCmdName,
          commandExamples: [],
          events: []
        };
      }

      const prevEvents = total.commands[currentCmdName].events;
      const newEvents = currentFile.producedEvents.map((pe) => pe.name);

      total.commands[currentCmdName].events = [...new Set([].concat(prevEvents, newEvents))];
      total.commands[currentCmdName].commandExamples.push(currentFile.command);

      total.events = currentFile.producedEvents.reduce((totalEvents, currentEvent) => {
        if (!totalEvents[currentEvent.name]) {
          totalEvents[currentEvent.name] = {
            event: currentEvent.name,
            eventExamples: []
          };
        }

        totalEvents[currentEvent.name].eventExamples.push(currentEvent);

        return totalEvents;
      }, total.events);

      return total;
    },
    {
      commands: {},
      events: {}
    }
  );

  const commandList = Object.values(cmdEvMap.commands);
  commandList.sort((cA, cB) => cA.command.localeCompare(cB.command));

  const eventList = Object.values(cmdEvMap.events);
  eventList.sort((eA, eB) => eA.event.localeCompare(eB.event));
  return {commandList, eventList};
}

async function readAllFilesAndDeleteThem() {
  const allFiles = await fsp.readdir(DOCU_OUTPUT);

  const readFilePromises = allFiles.map(async (file) => {
    const raw = await fsp.readFile(path.join(DOCU_OUTPUT, file), 'utf-8');
    return JSON.parse(raw);
  });

  const fileContents = await Promise.all(readFilePromises).catch((err) => {
    console.error(err);
    throw new Error(err);
  });

  // remove files
  const deleteFilePromises = allFiles.map(async (file) => fsp.unlink(path.join(DOCU_OUTPUT, file)));
  await Promise.all(deleteFilePromises).catch((err) => {
    console.error('could not remove all docu files');
    throw new Error(err);
  });

  return fileContents;
}

const toMarkdown = ({commandList, eventList}) =>
  `
# Poinz Command and Event Docu
This is an autogenerated docu. ${new Date()}

## Commands
${commandList.map(singleCmdToMarkdown).join('\n')}

## Events
${eventList.map(singleEvToMarkdown).join('\n')}
`;

const singleCmdToMarkdown = (cmd) =>
  `
### Command "${cmd.command}"

Produces ${cmd.events.map((e) => `[${e}](#${e})   `).join(', ')}

Example:
\`\`\`
${JSON.stringify(cmd.commandExamples[0], null, 4)}
\`\`\`

 `;

const singleEvToMarkdown = (ev) =>
  `
### <a name="${ev.event}"></a>Event "${ev.event}"

Example:
\`\`\`
${JSON.stringify(ev.eventExamples[0], null, 4)}
\`\`\`


 `;
